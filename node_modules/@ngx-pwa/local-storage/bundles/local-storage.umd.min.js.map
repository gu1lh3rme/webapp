{"version":3,"file":"local-storage.umd.min.js","sources":["../../out-tsc/lib/src/module.ts","../../out-tsc/lib/src/service/databases/local-database.ts","../../out-tsc/lib/src/tokens.ts","../../out-tsc/lib/src/service/databases/indexeddb-database.ts","../../out-tsc/lib/src/service/databases/localstorage-database.ts","../../out-tsc/lib/src/service/databases/mock-local-database.ts","../../out-tsc/lib/src/service/validation/json-validator.ts","../../out-tsc/lib/src/service/lib.service.ts"],"sourcesContent":["import { NgModule, PLATFORM_ID, Optional } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\nimport { JSONValidator } from './service/validation/json-validator';\nimport { LocalStorage } from './service/lib.service';\nimport { LocalDatabase } from './service/databases/local-database';\nimport { IndexedDBDatabase } from './service/databases/indexeddb-database';\nimport { LocalStorageDatabase } from './service/databases/localstorage-database';\nimport { MockLocalDatabase } from './service/databases/mock-local-database';\nimport { LOCAL_STORAGE_PREFIX } from './tokens';\n\nexport function databaseFactory(platformId: string, prefix: string | null) {\n\n  if (isPlatformBrowser(platformId) && ('indexedDB' in window) && (indexedDB !== undefined) && (indexedDB !== null)) {\n\n    /* Try with IndexedDB in modern browsers */\n    return new IndexedDBDatabase(prefix);\n\n  } else if (isPlatformBrowser(platformId) && ('localStorage' in window) && (localStorage !== undefined) && (localStorage !== null)) {\n\n    /* Try with localStorage in old browsers (IE9) */\n    return new LocalStorageDatabase(prefix);\n\n  } else {\n\n    /* Fake database for server-side rendering (Universal) */\n    return new MockLocalDatabase();\n\n  }\n\n}\n\n@NgModule({\n  providers: [\n    JSONValidator,\n    {\n      provide: LocalDatabase,\n      useFactory: databaseFactory,\n      deps: [PLATFORM_ID, [new Optional(), LOCAL_STORAGE_PREFIX]]\n    },\n    LocalStorage,\n  ]\n})\nexport class LocalStorageModule {}\n","import { Observable } from 'rxjs/Observable';\n\nexport abstract class LocalDatabase {\n\n  abstract getItem<T = any>(key: string): Observable<T | null>;\n  abstract setItem(key: string, data: any): Observable<boolean>;\n  abstract removeItem(key: string): Observable<boolean>;\n  abstract clear(): Observable<boolean>;\n\n}\n","import { InjectionToken, Provider } from '@angular/core';\n\n/**\n * Avoid using this directly, use `localStorageProviders()` for configuration.\n * It will be removed in v8.\n */\nexport const LOCAL_STORAGE_PREFIX = new InjectionToken<string>('localStoragePrefix');\n\nexport interface LocalStorageProvidersConfig {\n  prefix?: string;\n}\n\nexport function localStorageProviders(config: LocalStorageProvidersConfig): Provider[] {\n  return [\n    config.prefix ? { provide: LOCAL_STORAGE_PREFIX, useValue: config.prefix } : []\n  ];\n}\n","import { Injectable, Inject, Optional } from '@angular/core';\n\nimport { Observable } from 'rxjs/Observable';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { map, mergeMap, first, tap } from 'rxjs/operators';\nimport { fromEvent as observableFromEvent }  from 'rxjs/observable/fromEvent';\nimport { of as observableOf }  from 'rxjs/observable/of';\nimport { _throw as observableThrow } from 'rxjs/observable/throw';\nimport { race as observableRace }  from 'rxjs/observable/race';\n\nimport { LocalDatabase } from './local-database';\nimport { LOCAL_STORAGE_PREFIX } from '../../tokens';\n\n@Injectable()\nexport class IndexedDBDatabase extends LocalDatabase {\n\n  /**\n   * IndexedDB database name for local storage\n   */\n  protected dbName = 'ngStorage';\n  /**\n   * IndexedDB object store name for local storage\n   */\n  protected readonly objectStoreName = 'localStorage';\n  /**\n   * IndexedDB key path name for local storage (where an item's key will be stored)\n   */\n  protected readonly keyPath = 'key';\n  /**\n   * IndexedDB data path name for local storage (where items' value will be stored)\n   */\n  protected readonly dataPath = 'value';\n  /**\n   * IndexedDB database connection, wrapped in a RxJS ReplaySubject to be able to access the connection\n   * even after the connection success event happened\n   */\n  protected database: ReplaySubject<IDBDatabase>;\n\n  /**\n   * Connects to IndexedDB\n   */\n  constructor(@Optional() @Inject(LOCAL_STORAGE_PREFIX) protected prefix: string | null = null) {\n\n    super();\n\n    if (prefix) {\n\n      this.dbName = `${prefix}_${this.dbName}`;\n\n    }\n\n    /* Creating the RxJS ReplaySubject */\n    this.database = new ReplaySubject<IDBDatabase>();\n\n    /* Connecting to IndexedDB */\n    this.connect();\n\n  }\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string) {\n\n    /* Opening a trasaction and requesting the item in local storage */\n    return this.transaction().pipe(\n      map((transaction) => transaction.get(key)),\n      mergeMap((request) => {\n\n        /* Listening to the success event, and passing the item value if found, null otherwise */\n        const success = (observableFromEvent(request, 'success') as Observable<Event>).pipe(\n          map((event) => (event.target as IDBRequest).result),\n          map((result) => (result && (this.dataPath in result)) ? (result[this.dataPath] as T) : null)\n        );\n\n        /* Merging success and errors events and autoclosing the observable */\n        return (observableRace(success, this.toErrorObservable(request, `getter`)) as Observable<T | null>)\n          .pipe(first());\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  setItem(key: string, data: any) {\n\n    /* Storing null is not correctly supported by IndexedDB and unnecessary here */\n    if (data == null) {\n\n      return observableOf(true);\n\n    }\n\n    /* Transaction must be the same for read and write, to avoid concurrency issues */\n    const transaction$ = this.transaction('readwrite');\n    let transaction: IDBObjectStore;\n\n    return transaction$.pipe(\n      tap((value) => {\n        transaction = value;\n      }),\n      /* Check if the key already exists or not\n       * `getKey()` is only supported in indexedDb v2 (Chrome >= 58)\n       * For older browsers, the value is tested instead, but this could lead to an exception\n       * if `undefined` was stored by something else (native API or another lib) */\n      map(() => transaction.get(key)),\n      mergeMap((request) => {\n\n        /* Listening to the success event, and passing the item value if found, null otherwise */\n        const success = (observableFromEvent(request, 'success') as Observable<Event>).pipe(\n          map((event) => (event.target as IDBRequest).result),\n        );\n\n        /* Merging success and errors events and autoclosing the observable */\n        return (observableRace(success, this.toErrorObservable(request, `setter`)))\n          .pipe(first());\n\n      }),\n      mergeMap((existingValue) => {\n\n          /* Adding or updating local storage, based on previous checking */\n          const request: IDBRequest = (existingValue === undefined ) ?\n            transaction.add({ [this.dataPath]: data }, key) :\n            transaction.put({ [this.dataPath]: data }, key);\n\n          /* Merging success (passing true) and error events and autoclosing the observable */\n          return (observableRace(this.toSuccessObservable(request), this.toErrorObservable(request, `setter`)) as Observable<boolean>)\n            .pipe(first());\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  removeItem(key: string) {\n\n    /* Opening a transaction and checking if the item exists in local storage */\n    return this.getItem(key).pipe(\n      mergeMap((data) => {\n\n        /* If the item exists in local storage */\n        if (data != null) {\n\n          /* Opening a transaction */\n          return this.transaction('readwrite').pipe(mergeMap((transaction) => {\n\n            /* Deleting the item in local storage */\n            const request = transaction.delete(key);\n\n            /* Merging success (passing true) and error events and autoclosing the observable */\n            return (observableRace(this.toSuccessObservable(request), this.toErrorObservable(request, `remover`)) as Observable<boolean>)\n              .pipe(first());\n\n          }));\n\n        }\n\n        /* Passing true if the item does not exist in local storage */\n        return observableOf(true);\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  clear() {\n\n    /* Opening a transaction */\n    return this.transaction('readwrite').pipe(\n      mergeMap((transaction) => {\n\n        /* Deleting all items from local storage */\n        const request = transaction.clear();\n\n        /* Merging success (passing true) and error events and autoclosing the observable */\n        return (observableRace(this.toSuccessObservable(request), this.toErrorObservable(request, `clearer`)) as Observable<boolean>)\n          .pipe(first());\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Connects to IndexedDB and creates the object store on first time\n   */\n  protected connect() {\n\n    /* Connecting to IndexedDB */\n    const request = indexedDB.open(this.dbName);\n\n    /* Listening the event fired on first connection, creating the object store for local storage */\n    (observableFromEvent(request, 'upgradeneeded') as Observable<Event>)\n      .pipe(first())\n      .subscribe((event) => {\n\n        /* Getting the database connection */\n        const database = (event.target as IDBRequest).result as IDBDatabase;\n\n        /* Checking if the object store already exists, to avoid error */\n        if (!database.objectStoreNames.contains(this.objectStoreName)) {\n\n          /* Creating the object store for local storage */\n          database.createObjectStore(this.objectStoreName);\n\n        }\n\n      });\n\n    /* Listening the success event and converting to an RxJS Observable */\n    const success = observableFromEvent(request, 'success') as Observable<Event>;\n\n    /* Merging success and errors events */\n    (observableRace(success, this.toErrorObservable(request, `connection`)) as Observable<Event>)\n      .pipe(first())\n      .subscribe((event) => {\n\n        /* Storing the database connection for further access */\n        this.database.next((event.target as IDBRequest).result as IDBDatabase);\n\n      }, (error) => {\n\n        this.database.error(error as Error);\n\n      });\n\n  }\n\n  /**\n   * Opens an IndexedDB transaction and gets the local storage object store\n   * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations\n   * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable\n   */\n  protected transaction(mode: 'readonly' | 'readwrite' = 'readonly') {\n\n    /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */\n    return this.database\n      .pipe(map((database) => database.transaction([this.objectStoreName], mode).objectStore(this.objectStoreName)));\n\n  }\n\n  /**\n   * Transforms a IndexedDB success event in an RxJS Observable\n   * @param request The request to listen\n   * @returns A RxJS Observable with true value\n   */\n  protected toSuccessObservable(request: IDBRequest) {\n\n    /* Transforming a IndexedDB success event in an RxJS Observable with true value */\n    return (observableFromEvent(request, 'success') as Observable<Event>)\n      .pipe(map(() => true));\n\n  }\n\n  /**\n   * Transforms a IndexedDB error event in an RxJS ErrorObservable\n   * @param request The request to listen\n   * @param error Optionnal details about the error's origin\n   * @returns A RxJS ErrorObservable\n   */\n  protected toErrorObservable(request: IDBRequest, error = ``) {\n\n    /* Transforming a IndexedDB error event in an RxJS ErrorObservable */\n    return (observableFromEvent(request, 'error') as Observable<Event>)\n      .pipe(mergeMap((event) => observableThrow(new Error(`IndexedDB ${error} issue : ${request.error.message}.`))));\n\n  }\n\n}\n","import { Injectable, Optional, Inject } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { map } from 'rxjs/operators';\nimport { of as observableOf } from 'rxjs/observable/of';\nimport { _throw as observableThrow } from 'rxjs/observable/throw';\n\nimport { LocalDatabase } from './local-database';\nimport { LOCAL_STORAGE_PREFIX } from '../../tokens';\n\n@Injectable()\nexport class LocalStorageDatabase extends LocalDatabase {\n\n  protected prefix = '';\n\n  /**\n   * @param prefix Optional prefix to avoid collision in multiple apps on same subdomain\n   */\n  constructor(@Optional() @Inject(LOCAL_STORAGE_PREFIX) protected userPrefix: string | null = null) {\n\n    super();\n\n    if (userPrefix) {\n      this.prefix = `${userPrefix}_`;\n    }\n\n  }\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string): Observable<T | null> {\n\n    const unparsedData = localStorage.getItem(`${this.prefix}${key}`);\n    let parsedData: T | null = null;\n\n    if (unparsedData != null) {\n\n      try {\n        parsedData = JSON.parse(unparsedData);\n      } catch (error) {\n        return observableThrow(new Error(`Invalid data in localStorage.`));\n      }\n\n    }\n\n    return observableOf(parsedData);\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  setItem(key: string, data: any) {\n\n    if (data !== undefined) {\n\n      localStorage.setItem(`${this.prefix}${key}`, JSON.stringify(data));\n\n    }\n\n    return observableOf(true);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  removeItem(key: string) {\n\n    localStorage.removeItem(`${this.prefix}${key}`);\n\n    return observableOf(true);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  clear() {\n\n    localStorage.clear();\n\n    return observableOf(true);\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { map } from 'rxjs/operators';\nimport { of as observableOf } from 'rxjs/observable/of';\n\nimport { LocalDatabase } from './local-database';\n\n@Injectable()\nexport class MockLocalDatabase extends LocalDatabase {\n\n  protected localStorage = new Map<string, any>();\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n   getItem<T = any>(key: string) {\n\n    const rawData: T | null = this.localStorage.get(key);\n\n    return observableOf((rawData !== undefined) ? rawData : null);\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   setItem(key: string, data: any) {\n\n    this.localStorage.set(key, data);\n\n    return observableOf(true);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   removeItem(key: string) {\n\n    this.localStorage.delete(key);\n\n    return observableOf(true);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   clear() {\n\n    this.localStorage.clear();\n\n    return observableOf(true);\n\n  }\n\n}\n","import { JSONSchema, JSONSchemaType } from './json-schema';\n\n/**\n * @todo Add other JSON Schema validation features\n */\nexport class JSONValidator {\n\n  protected readonly simpleTypes = ['string', 'number', 'boolean', 'object'];\n\n  protected isObjectNotNull(value: any) {\n\n    return (value !== null) && (typeof value === 'object');\n\n  }\n\n  /**\n   * Validate a JSON data against a JSON Schema\n   * @param data JSON data to validate\n   * @param schema Subset of JSON Schema\n   * @returns If data is valid : true, if it is invalid : false, and throws if the schema is invalid\n   */\n  validate(data: any, schema: JSONSchema) {\n\n    if (!this.isObjectNotNull(schema)) {\n\n      throw new Error(`A schema must be an object (unlike spec, booleans are not supported to enforce strict types).`);\n\n    }\n\n    if ((!schema.hasOwnProperty('type') || schema.type === 'array' || schema.type === 'object')\n    && !schema.hasOwnProperty('properties') && !schema.hasOwnProperty('items')) {\n\n      throw new Error(`Each value must have a 'type' or 'properties' or 'items', to enforce strict types.`);\n\n    }\n\n    if (schema.hasOwnProperty('type') && !this.validateType(data, schema)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('items') && !this.validateItems(data, schema)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('properties')) {\n\n      if (schema.hasOwnProperty('required') && !this.validateRequired(data, schema)) {\n        return false;\n      }\n\n      if (!this.validateProperties(data, schema)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateProperties(data: {}, schema: JSONSchema) {\n\n    if (!this.isObjectNotNull(data)) {\n\n      return false;\n\n    }\n\n    if (!schema.properties || !this.isObjectNotNull(schema.properties)) {\n\n      throw new Error(`'properties' must be a schema object.`);\n\n    }\n\n    /**\n     * Check if the object doesn't have more properties than expected\n     * Equivalent of additionalProperties: false\n     */\n    if (Object.keys(schema.properties).length < Object.keys(data).length) {\n\n      return false;\n\n    }\n\n    /* Recursively validate all properties */\n    for (let property in schema.properties) {\n\n      if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {\n\n        if (!this.validate(data[property], schema.properties[property])) {\n\n          return false;\n\n        }\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateRequired(data: {}, schema: JSONSchema) {\n\n    if (!this.isObjectNotNull(data)) {\n\n      return false;\n\n    }\n\n    if (!Array.isArray(schema.required)) {\n\n      throw new Error(`'required' field must be an array. Note that since JSON Schema draft 6, booleans are not supported anymore.`);\n\n    }\n\n    for (let requiredProp of schema.required) {\n\n      if (typeof requiredProp !== 'string') {\n\n        throw new Error(`'required' array must contain strings only.`);\n\n      }\n\n      /* Checks if the property is present in the schema 'properties' */\n      if (!schema.properties || !schema.properties.hasOwnProperty(requiredProp)) {\n\n        throw new Error(`'required' properties must be described in 'properties' too.`);\n\n      }\n\n      /* Checks if the property is present in the data */\n      if (!data.hasOwnProperty(requiredProp)) {\n\n        return false;\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateType(data: any, schema: JSONSchema) {\n\n    if (Array.isArray(schema.type)) {\n\n      return this.validateTypeList(data, schema);\n\n    }\n\n    if (typeof schema.type !== 'string') {\n\n      throw new Error(`'type' must be a string (arrays of types are not supported yet).`);\n\n    }\n\n    if ((schema.type === 'null') && (data !== null)) {\n\n      return false;\n\n    }\n\n    if ((this.simpleTypes.indexOf(schema.type) !== -1) && (typeof data !== schema.type)) {\n\n      return false;\n\n    }\n\n    if ((schema.type === 'integer') && ((typeof data !== 'number') || !Number.isInteger(data))) {\n\n      return false;\n\n    }\n\n    return true;\n\n  }\n\n\n  protected validateTypeList(data: any, schema: JSONSchema) {\n\n    const types = schema.type as JSONSchemaType[];\n\n    const typesTests: boolean[] = [];\n\n    for (let type of types) {\n\n      typesTests.push(this.validateType(data, { type }));\n\n    }\n\n    return (typesTests.indexOf(true) !== -1);\n\n  }\n\n  protected validateItems(data: any[], schema: JSONSchema) {\n\n    if (!Array.isArray(data)) {\n\n      return false;\n\n    }\n\n    if (Array.isArray(schema.items)) {\n\n      return this.validateItemsList(data, schema);\n\n    }\n\n    if (!schema.items || !this.isObjectNotNull(schema.items)) {\n\n      throw new Error(`'items' must be a schema object.`);\n\n    }\n\n    for (let value of data) {\n\n      if (!this.validate(value, schema.items)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateItemsList(data: any, schema: JSONSchema) {\n\n    const items = schema.items as JSONSchema[];\n\n    if (data.length !== items.length) {\n\n      return false;\n\n    }\n\n    for (let i = 0; i < items.length; i += 1) {\n\n      if (!this.validate(data[i], items[i])) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { mergeMap } from 'rxjs/operators';\nimport { _throw as observableThrow } from 'rxjs/observable/throw';\nimport { of as observableOf } from 'rxjs/observable/of';\n\nimport { LocalDatabase } from './databases/local-database';\nimport { JSONSchema } from './validation/json-schema';\nimport { JSONValidator } from './validation/json-validator';\n\nexport interface LSGetItemOptions {\n  schema?: JSONSchema | null;\n}\n\n@Injectable()\nexport class LocalStorage {\n\n  protected readonly getItemOptionsDefault = {\n    schema: null\n  };\n\n  constructor(protected database: LocalDatabase, protected jsonValidator: JSONValidator) {}\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string, options: LSGetItemOptions = this.getItemOptionsDefault): Observable<T | null> {\n\n    return this.database.getItem<T>(key).pipe(\n\n      /* Validate data upon a json schema if requested */\n      mergeMap((data) => {\n\n        if (options.schema && data !== null) {\n\n          let validation = true;\n\n          try {\n            validation = this.jsonValidator.validate(data, options.schema);\n          } catch (error) {\n            return observableThrow(error);\n          }\n\n          if (!validation) {\n            return observableThrow(new Error(`JSON invalid`));\n          }\n\n        }\n\n        return observableOf(data);\n\n      }));\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   setItem(key: string, data: any): Observable<boolean> {\n\n    return this.database.setItem(key, data);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   removeItem(key: string): Observable<boolean> {\n\n    return this.database.removeItem(key);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   clear(): Observable<boolean> {\n\n    return this.database.clear();\n\n  }\n\n  /**\n   * Sets an item in local storage, and auto-subscribes\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   */\n  setItemSubscribe(key: string, data: any): void {\n\n    this.setItem(key, data).subscribe(() => {}, () => {});\n\n  }\n\n  /**\n   * Deletes an item in local storage, and auto-subscribes\n   * @param key The item's key\n   */\n   removeItemSubscribe(key: string): void {\n\n    this.removeItem(key).subscribe(() => {}, () => {});\n\n  }\n\n  /** Deletes all items from local storage, and auto-subscribes */\n  clearSubscribe(): void {\n\n    this.clear().subscribe(() => {}, () => {});\n\n  }\n\n}\n"],"names":["platformId","prefix","isPlatformBrowser","window","undefined","indexedDB","IndexedDBDatabase","localStorage","LocalStorageDatabase","MockLocalDatabase","LocalDatabase","LOCAL_STORAGE_PREFIX","InjectionToken","_super","_this","dbName","database","ReplaySubject","connect","__extends","key","this","transaction","pipe","map","get","mergeMap","request","success","observableFromEvent","event","result","dataPath","observableRace","toErrorObservable","first","data","observableOf","tap","value","existingValue","add","_a","put","_b","toSuccessObservable","getItem","delete","clear","open","subscribe","objectStoreNames","contains","objectStoreName","createObjectStore","next","error","mode","objectStore","observableThrow","Error","message","Injectable","Optional","Inject","userPrefix","unparsedData","parsedData","JSON","parse","setItem","stringify","removeItem","Map","rawData","set","JSONValidator","schema","isObjectNotNull","hasOwnProperty","type","validateType","validateItems","validateRequired","validateProperties","properties","Object","keys","length","property","validate","Array","isArray","required","_i","requiredProp","validateTypeList","simpleTypes","indexOf","Number","isInteger","typesTests","types_1","push","items","validateItemsList","data_1","i","jsonValidator","LocalStorage","options","getItemOptionsDefault","validation","NgModule","providers","provide","useFactory","databaseFactory","deps","PLATFORM_ID","config","useValue"],"mappings":"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"}